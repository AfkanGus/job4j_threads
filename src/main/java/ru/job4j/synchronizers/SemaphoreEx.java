package ru.job4j.synchronizers;

import java.util.concurrent.Semaphore;

/**
 * 6. Синхронизаторы [#504906].
 * Синхронизаторы - вспомогательные классы для синхр.потоков.
 * semaphore.acquire(), который блокирует поток, если нет доступных разрешений.
 * В данном случае доступно 5 разрешений, поэтому 5 потоков смогут выполнить
 * acquire() без блокировки.
 * Если разрешений не хватает, поток будет ожидать.
 * После завершения задания поток освобождает разрешение с помощью
 * semaphore.release(1), что увеличивает количество доступных разрешений на 1.
 * семафор управляет выполнением потоков, ограничивая доступ к критической секции до тех пор,
 * пока не будет освобождено хотя бы одно разрешение.
 */
public class SemaphoreEx {
    public SemaphoreEx(int i) {
    }

    public static void main(String[] args) throws InterruptedException {
        /* Это означает, что до 0 потоков могут одновременно получить доступ к критической секции*/
        Semaphore semaphore = new Semaphore(0);
        Runnable task = () -> {
            try {
                semaphore.acquire();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            /*Когда поток получит разрешение, он выполнит эту строку код*/
            System.out.println("Нить выполнила задачу");

            /*После завершения задачи освобождаем разрешение для других потоков (если требуется)*/
            semaphore.release();
        };
        new Thread(task).start();
        Thread.sleep(3000);

        /*После паузы, основной поток освобождает 1 разрешение семафора.*/
        semaphore.release(1); /*Это позволяет второму потоку продолжить выполнение.*/
    }
}

